<html>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
      <div class="mermaid">
    
        classDiagram
          class AnnotatedItem {
          }
          class AsyncQuicStream {
          }
          class AttemptManager {
            retry_state : str
          }
          class BSON {
            decode(codec_options: CodecOptions[Any]) dict[str, Any]
            encode(document: Mapping[str, Any], check_keys: bool, codec_options: CodecOptions[Any]) BSON
          }
          class Backend {
            Distribution : Type[BaseDistribution]
            Environment : Type[BaseEnvironment]
            NAME : str
          }
          class BaseAction {
            NAME : Optional[t.Optional[str]]
            REPR_FIELDS : t.Sequence[str]
          }
          class BaseRetrying {
            after : t.Callable[['RetryCallState'], None]
            before : t.Callable[['RetryCallState'], None]
            before_sleep : Optional[t.Optional[t.Callable[['RetryCallState'], None]]]
            reraise : bool
            retry : str
            retry_error_callback : Optional[t.Optional[t.Callable[['RetryCallState'], t.Any]]]
            retry_error_cls : t.Type[RetryError]
            sleep : t.Callable[[t.Union[int, float]], None]
            statistics
            stop : str
            wait : str
            begin() None
            copy(sleep: t.Union[t.Callable[[t.Union[int, float]], None], object], stop: t.Union['StopBaseT', object], wait: t.Union['WaitBaseT', object], retry: t.Union[retry_base, object], before: t.Union[t.Callable[['RetryCallState'], None], object], after: t.Union[t.Callable[['RetryCallState'], None], object], before_sleep: t.Union[t.Optional[t.Callable[['RetryCallState'], None]], object], reraise: t.Union[bool, object], retry_error_cls: t.Union[t.Type[RetryError], object], retry_error_callback: t.Union[t.Optional[t.Callable[['RetryCallState'], t.Any]], object]) 'BaseRetrying'
            iter(retry_state: 'RetryCallState') t.Union[DoAttempt, DoSleep, t.Any]
            wraps(f: WrappedFn) WrappedFn
          }
          class CodeTagFilter {
            tag_re
            filter(lexer, stream)
          }
          class Command {
            command_consumes_arguments : bool
            ensure_string_list(option)
            reinitialize_command(command, reinit_subcommands)
          }
          class Context {
            name : NoneType
            path
          }
          class ContextualVersionConflict {
            required_by
          }
          class ContextualVersionConflict {
            required_by
          }
          class ConverterState {
            diagram_kwargs : dict
            diagrams : Dict[int, EditablePartial[NamedDiagram]]
            extracted_diagram_names : Set[str]
            index : int
            unnamed_index : int
            extract_into_diagram(el_id: int)
            generate_index() int
            generate_unnamed() int
          }
          class DefaultProvider {
            get_resource_stream(manager, resource_name)
          }
          class DefaultProvider {
            get_resource_stream(manager, resource_name)
          }
          class DeprecatedTuple {
          }
          class DistInfoDistribution {
            EQEQ
            PKG_INFO : str
          }
          class DistInfoDistribution {
            EQEQ
            PKG_INFO : str
          }
          class DistlibException {
          }
          class Distribution {
            PKG_INFO : str
            extras
            hashcmp
            key
            location : NoneType
            parsed_version
            platform : NoneType
            precedence : int
            project_name
            py_version
            version
            activate(path, replace)
            as_requirement()
            check_version_conflict()
            clone()
            egg_name()
            from_filename(filename, metadata)
            from_location(location, basename, metadata)
            get_entry_info(group, name)
            get_entry_map(group)
            has_version()
            insert_on(path, loc, replace)
            load_entry_point(group, name)
            requires(extras)
          }
          class Distribution {
            PKG_INFO : str
            extras
            hashcmp
            key
            location : NoneType
            parsed_version
            platform : NoneType
            precedence : int
            project_name
            py_version
            version
            activate(path, replace)
            as_requirement()
            check_version_conflict()
            clone()
            egg_name()
            from_filename(filename, metadata)
            from_location(location, basename, metadata)
            get_entry_info(group, name)
            get_entry_map(group)
            has_version()
            insert_on(path, loc, replace)
            load_entry_point(group, name)
            requires(extras)
          }
          class Distribution {
            entry_points
            files
            metadata
            name
            requires
            version
            at(path)
            discover()
            from_name(name: str)
            locate_file(path)*
            read_text(filename)*
          }
          class DistributionFinder {
            find_distributions(context)*
          }
          class DistributionNotFound {
            req
            requirers
            requirers_str
            report()
          }
          class DistributionNotFound {
            req
            requirers
            requirers_str
            report()
          }
          class DistutilsLoader {
            create_module(spec)
            exec_module(module)*
          }
          class DistutilsMetaFinder {
            sensitive_tests : list
            spec_for_distutils
            find_spec(fullname, path, target)
            frame_file_is_setup(frame)
            is_cpython()
            pip_imported_during_build()
            spec_for_distutils()
            spec_for_pip()
            spec_for_sensitive_tests()
          }
          class DoAttempt {
          }
          class DoSleep {
          }
          class EachItem {
            all_label : str
          }
          class EditablePartial {
            args : list
            func : Callable[..., T]
            kwargs : dict
            name
            from_call(func: Callable[..., T]) 'EditablePartial[T]'
          }
          class EggInfoDistribution {
          }
          class EggInfoDistribution {
          }
          class EggMetadata {
            egg_info
            loader
            module_path
            zip_pre
          }
          class EggMetadata {
            egg_info
            loader
            module_path
            zip_pre
          }
          class EggProvider {
            egg_info
            egg_name
            egg_root
          }
          class EggProvider {
            egg_info
            egg_name
            egg_root
          }
          class ElementState {
            complete : bool
            converted
            element : ParserElement
            extract : bool
            name : NoneType, Optional[typing.Optional[str]]
            number : int
            parent
            parent_index : Optional[typing.Optional[int]]
            mark_for_extraction(el_id: int, state: 'ConverterState', name: str, force: bool)
          }
          class EmptyProvider {
            module_path : NoneType
          }
          class EmptyProvider {
            module_path : NoneType
          }
          class Encoding {
            codec_info
            name
          }
          class EntryPoint {
            attrs : tuple
            dist : NoneType
            extras : tuple
            module_name
            name
            pattern
            load(require)
            parse(src, dist)
            parse_group(group, lines, dist)
            parse_map(data, dist)
            require(env, installer)
            resolve()
          }
          class EntryPoint {
            attrs : tuple
            dist : NoneType
            extras : tuple
            module_name
            name
            pattern
            load(require)
            parse(src, dist)
            parse_group(group, lines, dist)
            parse_map(data, dist)
            require(env, installer)
            resolve()
          }
          class EntryPoint {
            attr
            dist : Optional['Distribution']
            extras
            group : str
            module
            name : str
            pattern
            value : str
            load()
            matches()
          }
          class EntryPoints {
            groups
            names
            select()
          }
          class Environment {
            platform
            python
            add(dist)
            best_match(req, working_set, installer, replace_conflicting)
            can_add(dist)
            obtain(requirement, installer)
            remove(dist)
            scan(search_path)
          }
          class Environment {
            platform
            python
            add(dist)
            best_match(req, working_set, installer, replace_conflicting)
            can_add(dist)
            obtain(requirement, installer)
            remove(dist)
            scan(search_path)
          }
          class ErrorToken {
          }
          class ExtractionError {
            cache_path
            manager
            original_error
          }
          class ExtractionError {
            cache_path
            manager
            original_error
          }
          class FastPath {
            joinpath
            mtime
            root
            children()
            joinpath(child)
            lookup(mtime)
            search(name)
            zip_children()
          }
          class FileHash {
            mode
            value
          }
          class FileMetadata {
            path
            get_metadata(name)
            get_metadata_lines(name)
            has_metadata(name)
          }
          class FileMetadata {
            path
            get_metadata(name)
            get_metadata_lines(name)
            has_metadata(name)
          }
          class FoldedCase {
            in_(other)
            index(sub)
            lower()
            split(splitter, maxsplit)
          }
          class FoldedCase {
            in_(other)
            index(sub)
            lower()
            split(splitter, maxsplit)
          }
          class Future {
            attempt_number : int
            failed
            construct(attempt_number: int, value: t.Any, has_exception: bool) 'Future'
          }
          class GobbleFilter {
            n : int
            filter(lexer, stream)
            gobble(value, left)
          }
          class GridFS {
            delete(file_id: Any, session: Optional[ClientSession]) None
            exists(document_or_id: Optional[Any], session: Optional[ClientSession]) bool
            find() GridOutCursor
            find_one(filter: Optional[Any], session: Optional[ClientSession]) Optional[GridOut]
            get(file_id: Any, session: Optional[ClientSession]) GridOut
            get_last_version(filename: Optional[str], session: Optional[ClientSession]) GridOut
            get_version(filename: Optional[str], version: Optional[int], session: Optional[ClientSession]) GridOut
            list(session: Optional[ClientSession]) list[str]
            new_file() GridIn
            put(data: Any) Any
          }
          class GridFSBucket {
            delete(file_id: Any, session: Optional[ClientSession]) None
            download_to_stream(file_id: Any, destination: Any, session: Optional[ClientSession]) None
            download_to_stream_by_name(filename: str, destination: Any, revision: int, session: Optional[ClientSession]) None
            find() GridOutCursor
            open_download_stream(file_id: Any, session: Optional[ClientSession]) GridOut
            open_download_stream_by_name(filename: str, revision: int, session: Optional[ClientSession]) GridOut
            open_upload_stream(filename: str, chunk_size_bytes: Optional[int], metadata: Optional[Mapping[str, Any]], session: Optional[ClientSession]) GridIn
            open_upload_stream_with_id(file_id: Any, filename: str, chunk_size_bytes: Optional[int], metadata: Optional[Mapping[str, Any]], session: Optional[ClientSession]) GridIn
            rename(file_id: Any, new_filename: str, session: Optional[ClientSession]) None
            upload_from_stream(filename: str, source: Any, chunk_size_bytes: Optional[int], metadata: Optional[Mapping[str, Any]], session: Optional[ClientSession]) ObjectId
            upload_from_stream_with_id(file_id: Any, filename: str, source: Any, chunk_size_bytes: Optional[int], metadata: Optional[Mapping[str, Any]], session: Optional[ClientSession]) None
          }
          class IMetadataProvider {
            get_metadata()*
            get_metadata_lines()*
            has_metadata()*
            metadata_isdir()*
            metadata_listdir()*
            run_script(namespace)*
          }
          class IMetadataProvider {
            get_metadata()*
            get_metadata_lines()*
            has_metadata()*
            metadata_isdir()*
            metadata_listdir()*
            run_script(namespace)*
          }
          class IResourceProvider {
            get_resource_filename(resource_name)*
            get_resource_stream(resource_name)*
            get_resource_string(resource_name)*
            has_resource()*
            resource_isdir()*
            resource_listdir()*
          }
          class IResourceProvider {
            get_resource_filename(resource_name)*
            get_resource_stream(resource_name)*
            get_resource_string(resource_name)*
            has_resource()*
            resource_isdir()*
            resource_listdir()*
          }
          class IncrementalDecoder {
            encoding : NoneType
            decode(input, final)
          }
          class IncrementalEncoder {
            encode
          }
          class InstallationResult {
            name : str
          }
          class KeywordCaseFilter {
            convert
            filter(lexer, stream)
          }
          class Lookup {
            eggs : FreezableDefaultDict
            infos : FreezableDefaultDict
            search(prepared)
          }
          class MemoizedZipManifests {
            manifest_mod : manifest_mod
            load(path)
          }
          class MemoizedZipManifests {
            manifest_mod : manifest_mod
            load(path)
          }
          class MetadataPathFinder {
            find_distributions(context)
            invalidate_caches()
          }
          class MinimalDistribution {
            finalize_options()*
          }
          class NameHighlightFilter {
            names : set
            tokentype : _TokenType
            filter(lexer, stream)
          }
          class NoDists {
          }
          class NoDists {
          }
          class NullProvider {
            egg_info : NoneType
            egg_name : NoneType
            loader : NoneType
            module_path
            get_metadata(name)
            get_metadata_lines(name)
            get_resource_filename(manager, resource_name)
            get_resource_stream(manager, resource_name)
            get_resource_string(manager, resource_name)
            has_metadata(name)
            has_resource(resource_name)
            metadata_isdir(name)
            metadata_listdir(name)
            resource_isdir(resource_name)
            resource_listdir(resource_name)
            run_script(script_name, namespace)
          }
          class NullProvider {
            egg_info : NoneType
            egg_name : NoneType
            loader : NoneType
            module_path
            get_metadata(name)
            get_metadata_lines(name)
            get_resource_filename(manager, resource_name)
            get_resource_stream(manager, resource_name)
            get_resource_string(manager, resource_name)
            has_metadata(name)
            has_resource(resource_name)
            metadata_isdir(name)
            metadata_listdir(name)
            resource_isdir(resource_name)
            resource_listdir(resource_name)
            run_script(script_name, namespace)
          }
          class PEP440Warning {
          }
          class PEP440Warning {
          }
          class PackageNotFoundError {
            name
          }
          class PackagePath {
            dist
            hash : NoneType
            size : NoneType
            locate()
            read_binary()
            read_text(encoding)
          }
          class PathDistribution {
            locate_file(path)
            read_text(filename)
          }
          class PathMetadata {
            egg_info
            module_path
          }
          class PathMetadata {
            egg_info
            module_path
          }
          class PkgResourcesDeprecationWarning {
          }
          class PkgResourcesDeprecationWarning {
          }
          class Popen {
            wait(timeout)
          }
          class Prepared {
            legacy_normalized : NoneType
            name
            normalized : NoneType
            legacy_normalize(name)
            normalize(name)
          }
          class Process {
            info : dict
            pid
            as_dict(attrs, ad_value)
            children(recursive)
            cmdline()
            connections(kind)
            cpu_affinity(cpus)
            cpu_num()
            cpu_percent(interval)
            cpu_times()
            create_time()
            cwd()
            environ()
            exe()
            gids()
            io_counters()
            ionice(ioclass, value)
            is_running()
            kill()
            memory_full_info()
            memory_info()
            memory_info_ex()
            memory_maps(grouped)
            memory_percent(memtype)
            name()
            nice(value)
            num_ctx_switches()
            num_fds()
            num_handles()
            num_threads()
            oneshot()
            open_files()
            parent()
            parents()
            ppid()
            resume()
            rlimit(resource, limits)
            send_signal(sig)
            status()
            suspend()
            terminal()
            terminate()
            threads()
            uids()
            username()
            wait(timeout)
          }
          class PsutilTestCase {
            assertProcessGone(proc)
            get_testfn(suffix, dir)
            pyrun()
            spawn_children_pair()
            spawn_testproc()
            spawn_zombie()
          }
          class RaiseOnErrorTokenFilter {
            exception
            filter(lexer, stream)
          }
          class Requirement {
            extras : tuple
            hashCmp : tuple
            key
            project_name
            specs
            unsafe_name
            parse(s)
          }
          class Requirement {
            extras : tuple
            hashCmp : tuple
            key
            project_name
            specs
            unsafe_name
            parse(s)
          }
          class RequirementParseError {
          }
          class RequirementParseError {
          }
          class ResolutionError {
          }
          class ResolutionError {
          }
          class ResourceManager {
            cached_files : dict
            extraction_path : NoneType
            cleanup_resources(force)*
            extraction_error()
            get_cache_path(archive_name, names)
            postprocess(tempname, filename)
            resource_exists(package_or_requirement, resource_name)
            resource_filename(package_or_requirement, resource_name)
            resource_isdir(package_or_requirement, resource_name)
            resource_listdir(package_or_requirement, resource_name)
            resource_stream(package_or_requirement, resource_name)
            resource_string(package_or_requirement, resource_name)
            set_extraction_path(path)
          }
          class ResourceManager {
            cached_files : dict
            extraction_path : NoneType
            cleanup_resources(force)*
            extraction_error()
            get_cache_path(archive_name, names)
            postprocess(tempname, filename)
            resource_exists(package_or_requirement, resource_name)
            resource_filename(package_or_requirement, resource_name)
            resource_isdir(package_or_requirement, resource_name)
            resource_listdir(package_or_requirement, resource_name)
            resource_stream(package_or_requirement, resource_name)
            resource_string(package_or_requirement, resource_name)
            set_extraction_path(path)
          }
          class RetryAction {
            NAME : str
            REPR_FIELDS : tuple
            sleep : float
          }
          class RetryCallState {
            args : Any
            attempt_number : int
            fn : t.Optional[WrappedFn]
            idle_for : float
            kwargs : Any
            next_action : NoneType, Optional[t.Optional[RetryAction]]
            outcome : NoneType, Optional[t.Optional[Future]]
            outcome_timestamp : NoneType, Optional[t.Optional[float]]
            retry_object
            seconds_since_start
            start_time
            prepare_for_next_attempt() None
            set_exception(exc_info: t.Tuple[t.Type[BaseException], BaseException, 'types.TracebackType| None']) None
            set_result(val: t.Any) None
          }
          class RetryError {
            last_attempt : str
            reraise() 't.NoReturn'
          }
          class Retrying {
          }
          class Sectioned {
            read(text, filter_)
            section_pairs(text)
            valid(line)
          }
          class SeparatedValues {
            separator : str
          }
          class SeparatedValues {
            separator : str
          }
          class Splitter {
            args : tuple
          }
          class Splitter {
            args : tuple
          }
          class Stripper {
            lines : map
            prefix
            common_prefix(s1, s2)
            strip_prefix(lines)
          }
          class Stripper {
            lines : map
            prefix
            common_prefix(s1, s2)
            strip_prefix(lines)
          }
          class SymbolFilter {
            isabelle_symbols : dict
            lang_map : dict
            latex_symbols : dict
            symbols
            filter(lexer, stream)
          }
          class TestCase {
            assertRaisesRegex
            runTest()*
            subTest()
          }
          class TestMemoryLeak {
            retries : int
            times : int
            tolerance : int
            verbose : bool
            warmup_times : int
            call(fun)
            execute(fun, times, warmup_times, retries, tolerance)
            execute_w_exc(exc, fun)
            setUpClass()
            tearDownClass()
          }
          class ThreadTask {
            run()
            start()
            stop()
          }
          class TokenMergeFilter {
            filter(lexer, stream)
          }
          class TryAgain {
          }
          class UnknownExtra {
          }
          class UnknownExtra {
          }
          class VendorImporter {
            root_name
            search_path
            vendor_pkg
            vendored_names : set
            create_module(spec)
            exec_module(module)*
            find_spec(fullname, path, target)
            install()
            load_module(fullname)
          }
          class VendorImporter {
            root_name
            search_path
            vendor_pkg
            vendored_names : set
            create_module(spec)
            exec_module(module)*
            find_spec(fullname, path, target)
            install()
            load_module(fullname)
          }
          class VersionConflict {
            dist
            req
            report()
            with_context(required_by)
          }
          class VersionConflict {
            dist
            req
            report()
            with_context(required_by)
          }
          class VisibleWhitespaceFilter {
            newlines
            tabs
            wstt : bool
            filter(lexer, stream)
          }
          class WheelError {
          }
          class WordSet {
            camel_case()
            capitalized()
            dash_separated()
            from_class_name(subject)
            headless_camel_case()
            lowered()
            parse(identifier)
            space_separated()
            trim(item)
            trim_left(item)
            trim_right(item)
            underscore_separated()
          }
          class WordSet {
            camel_case()
            capitalized()
            dash_separated()
            from_class_name(subject)
            headless_camel_case()
            lowered()
            parse(identifier)
            space_separated()
            trim(item)
            trim_left(item)
            trim_right(item)
            underscore_separated()
          }
          class WorkingSet {
            by_key : dict
            callbacks : list
            entries : list
            entry_keys : dict
            normalized_to_canonical_keys : dict
            add(dist, entry, insert, replace)
            add_entry(entry)
            find(req)
            find_plugins(plugin_env, full_env, installer, fallback)
            iter_entry_points(group, name)
            require()
            resolve(requirements, env, installer, replace_conflicting, extras)
            run_script(requires, script_name)
            subscribe(callback, existing)
          }
          class WorkingSet {
            by_key : dict
            callbacks : list
            entries : list
            entry_keys : dict
            normalized_to_canonical_keys : dict
            add(dist, entry, insert, replace)
            add_entry(entry)
            find(req)
            find_plugins(plugin_env, full_env, installer, fallback)
            iter_entry_points(group, name)
            require()
            resolve(requirements, env, installer, replace_conflicting, extras)
            run_script(requires, script_name)
            subscribe(callback, existing)
          }
          class ZipManifests {
            load
            build(path)
          }
          class ZipManifests {
            load
            build(path)
          }
          class ZipProvider {
            eagers : NoneType
            zip_pre
            zipinfo
            get_resource_filename(manager, resource_name)
          }
          class ZipProvider {
            eagers : NoneType
            zip_pre
            zipinfo
            get_resource_filename(manager, resource_name)
          }
          class _ReqExtras {
            markers_pass(req, extras)
          }
          class _ReqExtras {
            markers_pass(req, extras)
          }
          class _TrivialRe {
            match(string)
          }
          class _automodule {
          }
          class _automodule {
          }
          class process_namespace {
            all
            getters : list
            ignored : list
            killers : list
            setters : list
            utils : list
            clear_cache()
            iter(ls, clear_cache)
            test()
            test_class_coverage(test_class, ls)
          }
          class retry {
            exception : Exception
            interval : float
            logfun : NoneType
            retries : NoneType
            timeout : NoneType
            sleep()
          }
          class shim {
          }
          class sic {
          }
          class system_namespace {
            all : list
            getters : list
            ignored : list
            test_class_coverage
            iter(ls)
          }
          class version_info {
            major : int
            micro : int
            minor : int
            releaselevel : str
            serial : int
          }
          ContextualVersionConflict --|> VersionConflict
          DefaultProvider --|> EggProvider
          DistInfoDistribution --|> Distribution
          DistributionNotFound --|> ResolutionError
          EggInfoDistribution --|> Distribution
          EggMetadata --|> ZipProvider
          EggProvider --|> NullProvider
          EmptyProvider --|> NullProvider
          FileMetadata --|> EmptyProvider
          IResourceProvider --|> IMetadataProvider
          MemoizedZipManifests --|> ZipManifests
          PathMetadata --|> DefaultProvider
          UnknownExtra --|> ResolutionError
          VersionConflict --|> ResolutionError
          ZipProvider --|> EggProvider
          RetryAction --|> BaseAction
          Retrying --|> BaseRetrying
          ContextualVersionConflict --|> VersionConflict
          DefaultProvider --|> EggProvider
          DistInfoDistribution --|> Distribution
          DistributionNotFound --|> ResolutionError
          EggInfoDistribution --|> Distribution
          EggMetadata --|> ZipProvider
          EggProvider --|> NullProvider
          EmptyProvider --|> NullProvider
          FileMetadata --|> EmptyProvider
          IResourceProvider --|> IMetadataProvider
          MemoizedZipManifests --|> ZipManifests
          PathMetadata --|> DefaultProvider
          UnknownExtra --|> ResolutionError
          VersionConflict --|> ResolutionError
          ZipProvider --|> EggProvider
          Popen --|> Process
          PsutilTestCase --|> TestCase
          TestMemoryLeak --|> PsutilTestCase
          EntryPoint --|> DeprecatedTuple
          MetadataPathFinder --|> DistributionFinder
          PathDistribution --|> Distribution
          EmptyProvider --* Distribution : _provider
          MemoizedZipManifests --* ZipProvider : _zip_manifests
          Future --* RetryCallState : outcome
          Future --* RetryCallState : outcome
          Encoding --* IncrementalDecoder : _fallback_encoding
          EmptyProvider --* Distribution : _provider
          MemoizedZipManifests --* ZipProvider : _zip_manifests
          Process --* TestMemoryLeak : _thisproc
          ResourceManager --o ExtractionError : manager
          EditablePartial --o ElementState : converted
          EditablePartial --o ElementState : parent
          BaseRetrying --o RetryCallState : retry_object
          ResourceManager --o ExtractionError : manager
          Distribution --o PackagePath : dist
  
       </div>
  </body>
</html>
